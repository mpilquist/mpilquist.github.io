
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>scodec - Part 1 - Introduction - mpilquist.github.io</title>
	<meta name="author" content="Michael Pilquist">

	
	<meta name="description" content="I recently started the scodec project to simplify handling of binary data in Scala. From the project page: This library focuses on contract-first and &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="mpilquist.github.io" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">mpilquist.github.io</a></h1>
<nav id="main-nav"><ul class="main">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories/talks">Talks</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories/talks">Talks</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:mpilquist.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		<a class="google" href="https://plus.google.com/106335582774991536012?rel=author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/mpilquist" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/mpilquist" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:mpilquist.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">Scodec - Part 1 - Introduction</h2>
	<div class="entry-content"><p>I recently started the <a href="http://github.com/mpilquist/scodec">scodec</a> project to simplify handling of binary data in Scala. From the project page:</p>

<blockquote><p>This library focuses on contract-first and pure functional encoding and decoding of binary data.
The following design constraints are considered:</p>

<ul>
<li>Binary structure should mirror protocol definitions and be self-evident under casual reading</li>
<li>Mapping binary structures to types should be statically verified</li>
<li>Encoding and decoding should be purely functional</li>
<li>Failures in encoding and decoding should provide descriptive errors</li>
<li>Compiler plugin should not be used</li>
</ul>


<p>As a result, the library is implemented as a combinator based DSL.
Performance is considered but yields to the above design constraints.</p></blockquote>

<p>This article will introduce some of the main abstractions in scodec and discuss some of the design decisions. Subsequent articles will discuss more interesting parts of scodec, including invariant functors and use of <a href="http://github.com/milessabing/shapeless">Shapeless</a>.</p>

<!-- more -->


<h2>Terminology</h2>

<ul>
<li><em>encoding</em> - converting a value in to its binary representation</li>
<li><em>decoding</em> - converting binary data in to a value</li>
<li><em>codec</em> - a value that can encode and decode values of a given Scala type</li>
</ul>


<h2>Representing Binary</h2>

<p>Binary data is passed around a lot in scodec. As such, a representation of binary data is needed. The representation must satisfy a number of constraints:</p>

<ul>
<li>Must be immutable</li>
<li>Must support bit operations such as <code>take(bitCount)</code>, <code>drop(bitCount)</code>, and typical bitwise operators (negation, and, or, xor, &hellip;)</li>
<li>Must support fast concatenation in order to handle encoding a number of values in to a single binary structure</li>
<li>Must support fast <code>take(bitCount)</code>/<code>drop(bitCount)</code> operations in order to allow fast decoding</li>
</ul>


<p>Focusing on individual bits as the fundamental element instead of bytes is the most unique constraint. By focusing on bits instead of bytes or words, the combinator DSL is able to support a more natural description of bit fields.</p>

<p><code>Array[Byte]</code> is an unsuitable representation given that it meets none of the stated constraints. <code>java.nio.ByteBuffer</code> does not provide a way to enforce immutable at the type level and fails on the other constraints. <code>Vector[Byte]</code> satisfies all constraints except for providing bit operations.</p>

<p>To satisfy these constraints, scodec includes the <code>BitVector</code> and <code>ByteVector</code> data types and the <code>BitwiseOperation</code> supporting trait. This approach allows the API provided to codec authors to be more focused than generic collections. Additionally, the backing implementation of <code>BitVector</code> and <code>ByteVector</code> can be changed for performance reasons without impacting users.</p>

<h3>BitwiseOperations</h3>

<p><code>BitwiseOperations</code> is a supporting trait that&rsquo;s extended by both <code>BitVector</code> and <code>ByteVector</code>. It provides bitwise shifting operators as well as bitwise negation, bitwise and, bitwise or, and bitwise xor.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">BitwiseOperations</span><span class="o">[</span><span class="kt">Repr</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="o">&lt;&lt;(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">leftShift</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">leftShift</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="o">&gt;&gt;(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">rightShift</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="o">&gt;&gt;&gt;(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">rightShift</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">rightShift</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">signExtension</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="n">unary_~</span><span class="o">()</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">not</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">not</span><span class="k">:</span> <span class="kt">Repr</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="o">&amp;(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">and</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">and</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="o">|(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">or</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">or</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">final</span> <span class="k">def</span> <span class="o">^(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="n">xor</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">xor</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>BitVector</h3>

<p><code>BitVector</code> represents an immutable sequence of bits. By extending the <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.IndexedSeqOptimized"><code>IndexedSeqOptimized[Boolean, BitVector]</code></a> trait from the Scala collection library, a bit vector can be used as a collection of booleans. As a bonus, most of the implementation is provided by <code>IndexedSeqOptimized</code> - albeit, sometimes inefficiently.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">BitVector</span> <span class="k">extends</span> <span class="nc">IndexedSeqOptimized</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">BitVector</span><span class="o">]</span> <span class="k">with</span> <span class="nc">BitwiseOperations</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toByteVector</span><span class="k">:</span> <span class="kt">ByteVector</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toByteArray</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toByteBuffer</span><span class="k">:</span> <span class="kt">ByteBuffer</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Constructing a bit vector can be done in a number of ways. The <code>apply</code> method on the bit vector companion allows direct wrapping of a <code>ByteVector</code>, <code>Array[Byte]</code>, or <code>java.nio.ByteBuffer</code>. To create a bit vector from literal bytes, the literal bytes can be passed directly to apply. For example, <code>BitVector(0x55, 0x2a)</code>.</p>

<p>When decoding, many codecs need to take a certain number of bits and convert them to a value. For example, a codec for a signed 32-bit integer might take 32 bits and return those bits converted to an <code>Int</code> along with the remaining bits in the input vector (via <code>input.drop(32)</code>). <code>BitVector#take</code> is insufficient for this task because taking <code>n</code> bits from a <code>m</code> bit vector where <code>n &gt; m</code> results in <code>m</code> bits being returned. As a result, every codec would need similar error handling for this case.</p>

<p>To simplify this case, <code>BitVector</code> has an <code>acquire</code> method, which gets a bit vector of exactly <code>n</code> bits or returns an error.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">acquire</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">BitVector</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">\/</span> <span class="n">left</span> <span class="n">s</span><span class="s">&quot;cannot acquire $n bits from a vector that contains $size bits&quot;</span>
</span><span class='line'>  <span class="k">else</span> <span class="o">\/</span> <span class="n">right</span> <span class="n">take</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note the use of Scalaz&rsquo;s disjunction (i.e., <code>\/</code>) data type, instead of <code>Option[BitVector]</code> or throwing an exception. By providing a disjunction that has a descriptive error message, overall error reporting is improved. (In general, I think Scalaz&rsquo;s disjunction is one of the most undervalued parts of Scalaz.)</p>

<p>The <code>acquire</code> method only handles getting the necessary bits. Converting the acquired bits to a value may fail. Combining bit acquisition with failure checked type conversion can be refactored in to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">consume</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">decode</span><span class="k">:</span> <span class="kt">BitVector</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="o">\/</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="o">(</span><span class="kt">BitVector</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">toDecode</span> <span class="k">&lt;-</span> <span class="n">acquire</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span><span class='line'>  <span class="n">decoded</span> <span class="k">&lt;-</span> <span class="n">decode</span><span class="o">(</span><span class="n">toDecode</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">drop</span><span class="o">(</span><span class="n">n</span><span class="o">),</span> <span class="n">decoded</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ByteVector</h3>

<p><code>ByteVector</code> represents an immutable sequence of bytes.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">ByteVector</span> <span class="k">extends</span> <span class="nc">IndexedSeqOptimized</span><span class="o">[</span><span class="kt">Byte</span>, <span class="kt">ByteVector</span><span class="o">]</span> <span class="k">with</span> <span class="nc">BitwiseOperations</span><span class="o">[</span><span class="kt">ByteVector</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toArray</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toByteBuffer</span><span class="k">:</span> <span class="kt">ByteBuffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="n">toArray</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toBitVector</span><span class="k">:</span> <span class="kt">BitVector</span> <span class="o">=</span> <span class="nc">BitVector</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">toHexadecimal</span><span class="k">:</span> <span class="kt">String</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Unsurprisingly, <code>ByteVector</code> is currently implemented by delegating to a <code>Vector[Byte]</code>. There are a number of potential improvements, including:</p>

<ul>
<li>for vectors with length &lt;= 8, use a special byte vector implementaiton backed by a single <code>Long</code> value</li>
<li>delegate to Akka&rsquo;s <a href="https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/util/ByteString.scala"><code>ByteString</code></a></li>
<li>write a custom vector-like structure that&rsquo;s manually specialized for bytes</li>
</ul>


<p>Before any of these performance improvements are implemented, benchmarks will be developed in order to measure impacts.</p>

<h2>Codecs</h2>

<p>With the basic data types out of the way, we can concretize the definition of a codec.</p>

<p>Encoding is represented by a function <code>A =&gt; String \/ BitVector</code>. By modeling encoding this way, a failure to encode a value of type <code>A</code> can be communicated without throwing an exception. For example, given a <code>Codec[Int]</code> that encodes unsigned 24-bit integers, calling encode with a negative integer would return an error message on the left side of the disjunction.</p>

<p>Decoding is represented by a function <code>BitVector =&gt; String \/ (BitVector, A)</code>. Similar to the rationale for encoding, a failure
to decode a value of type <code>A</code> results in an error message on the left side of the disjunction. Successful decoding results in a tuple of the remaining (non-consumed) bits and the decoded value.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">BitVector</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="o">(</span><span class="kt">BitVector</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Tuple Codec</h3>

<p>Consider a codec for a tuple <code>(A, B)</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">TupleCodec</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">codecA</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">codecB</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Codec</span><span class="o">.</span><span class="n">encodeBoth</span><span class="o">(</span><span class="n">codecA</span><span class="o">,</span> <span class="n">codecB</span><span class="o">)(</span><span class="n">t</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">t</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Codec</span><span class="o">.</span><span class="n">decodeBoth</span><span class="o">(</span><span class="n">codecA</span><span class="o">,</span> <span class="n">codecB</span><span class="o">)(</span><span class="n">buffer</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s implement <code>Codec.encodeBoth</code> and <code>Codec.decodeBoth</code>.</p>

<p>First, encoding:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">encodeBoth</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">codecA</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">codecB</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">BitVector</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure>


<p>Encoding is fairly straightforward. First, <code>a</code> is encoded, then <code>b</code> is encoded, and then the resulting vectors are concatenated. Any error results in the overall encoding failing. This is easily accomplished with a for-comprehension:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">encodeBoth</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">codecA</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">codecB</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">BitVector</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">encA</span> <span class="k">&lt;-</span> <span class="n">codecA</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="n">encB</span> <span class="k">&lt;-</span> <span class="n">codecB</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">encA</span> <span class="o">++</span> <span class="n">encB</span>
</span></code></pre></td></tr></table></div></figure>


<p>Second, decoding:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">decodeBoth</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
</span><span class='line'>  <span class="o">(</span><span class="n">codecA</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">codecB</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>  <span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="o">(</span><span class="kt">BitVector</span><span class="o">,</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="k">=</span> <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure>


<p>Decoding is accomplished by first decoding with <code>codecA</code>, then, assuming successful decoding, decoding the remaining bits with <code>codecB</code>, and finally returning both decoded values in a tuple. Any error results in the overall decoding failing. This could be implemented directly:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">decodeBoth</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
</span><span class='line'>  <span class="o">(</span><span class="n">codecA</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">codecB</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>  <span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="o">(</span><span class="kt">BitVector</span><span class="o">,</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">decA</span> <span class="k">=</span> <span class="n">codecA</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span>
</span><span class='line'>  <span class="n">decA</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">afterA</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">decB</span> <span class="k">=</span> <span class="n">codecB</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">afterA</span><span class="o">)</span>
</span><span class='line'>    <span class="n">decB</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">afterB</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">afterB</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can do better than this though. Note the type signature of <code>Codec#decode</code>: <code>BitVector =&gt; String \/ (BitVector, A)</code>. The <a href="https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/StateT.scala"><code>scalaz.StateT</code></a> monad transformer wraps functions of the form <code>S =&gt; F[(S, A)]</code> for a monad <code>F</code>. We can set <code>F</code> to <code>String \/ ?</code> resulting in <code>StateT[({type λ[+α] = Error \/ α})#λ, BitVector, A]</code>. This pattern occurs often enough when working with codecs to warrant special support:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">DecodingContext</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">+α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Error</span> <span class="kt">\/</span> <span class="kt">α</span><span class="o">})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">BitVector</span>, <span class="kt">A</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">DecodingContext</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">BitVector</span> <span class="o">=&gt;</span> <span class="nc">Error</span> <span class="o">\/</span> <span class="o">(</span><span class="nc">BitVector</span><span class="o">,</span> <span class="n">A</span><span class="o">))</span><span class="k">:</span> <span class="kt">DecodingContext</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">StateT</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">+α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Error</span> <span class="kt">\/</span> <span class="kt">α</span><span class="o">})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">BitVector</span>, <span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Returning to <code>decodeBoth</code>, we can use <code>DecodingContext</code> to implement it simply:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">decodeBoth</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
</span><span class='line'>  <span class="o">(</span><span class="n">codecA</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">codecB</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>  <span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="o">(</span><span class="kt">BitVector</span><span class="o">,</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">DecodingContext</span><span class="o">(</span><span class="n">codecA</span><span class="o">.</span><span class="n">decode</span><span class="o">)</span>
</span><span class='line'>    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">DecodingContext</span><span class="o">(</span><span class="n">codecB</span><span class="o">.</span><span class="n">decode</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'><span class="o">}.</span><span class="n">run</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Wrap up</h2>

<p>This article presented the basic data types used in scodec. In part 2, we&rsquo;ll look at the <code>Codec</code> trait in more detail and investigate how to convert a <code>Codec[A]</code> in to a <code>Codec[B]</code> given some relations between <code>A</code> and <code>B</code>.</p>
</div>


<div class="meta">
	<div class="date">




May 27th, 2013</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scodec/'>scodec</a>


</div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		<a class="addthis_button_tweet"></a>
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    Michael Pilquist

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'liftM';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://mpilquist.github.io/blog/2013/05/27/scodec-intro/';
        var disqus_url = 'http://mpilquist.github.io/blog/2013/05/27/scodec-intro/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-41236326-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>