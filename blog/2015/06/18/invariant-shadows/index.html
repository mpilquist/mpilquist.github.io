
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Invariant Shadows - mpilquist.github.io</title>
	<meta name="author" content="Michael Pilquist">

	
	<meta name="description" content="A common use case when working with binary protocols is decoding a value and then using the decoded value to determine how to decode the remaining &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="mpilquist.github.io" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">mpilquist.github.io</a></h1>
<nav id="main-nav"><ul class="main">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories/talks">Talks</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories/talks">Talks</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:mpilquist.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		<a class="google" href="https://plus.google.com/106335582774991536012?rel=author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/mpilquist" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/mpilquist" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:mpilquist.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">Invariant Shadows</h2>
	<div class="entry-content"><p>A common use case when working with binary protocols is decoding a value and then using the decoded value to determine how to decode the remaining bits. For example, consider a simple framing structure, made up of a 2-byte big endian unsigned integer field followed by <code>n</code> bytes, where <code>n</code> is the value in the first field. In order to decode this structure, we need to first decode the 2-byte size field, then use the decoded size to take that number of bytes from the remainder.</p>

<p>This can be represented with <a href="http://scodec.org">scodec</a> like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scodec._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scodec.bits._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scodec.codecs._</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">decoder</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">ByteVector</span><span class="o">]</span> <span class="k">=</span> <span class="n">uint16</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="n">size</span> <span class="k">=&gt;</span> <span class="n">bytes</span><span class="o">(</span><span class="n">size</span> <span class="o">*</span> <span class="mi">8L</span><span class="o">)</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, we used <code>flatMap</code> to express the dependency between <code>uint16: Codec[Int]</code> and the bytes decoder. However, <code>flatMap</code> on <code>Codec</code> returns
a <code>Decoder[B]</code>, not a <code>Codec[B]</code>, so by using <code>flatMap</code>, we lose the ability to encode.</p>

<p>It turns out that it is impossible to define <code>flatMap</code> for <code>Codec</code> with the expected signature. Consider this attempt:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Encoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">sizeBound</span><span class="o">.</span><span class="n">atLeast</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>      <span class="o">???</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The implementation of <code>decode</code> is straightforward, but we arrive at an impasse when trying to implement <code>encode</code>. We have a <code>Codec[A]</code>, a function <code>A =&gt; Codec[B]</code> and a value of type <code>B</code>. We cannot use the <code>Codec[A]</code> to encode unless we have an <code>A</code>, and we cannot get access to a <code>Codec[B]</code> unless we have an <code>A</code> to apply to the function. Hence, we cannot implement <code>flatMap</code> on <code>Codec</code> &ndash; meaning that there is no monad for <code>Codec</code>!</p>

<p>So how were we able to call <code>flatMap</code> on <code>Codec</code> in our first example? That worked because <code>Decoder</code> defines a <code>flatMap</code> method like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Because <code>Codec</code> extends from <code>Decoder</code>, it inherits this definition of <code>flatMap</code>, which is why flat mapping a <code>Codec</code> results in a <code>Decoder</code>.</p>

<p>Nonetheless, we can change the signature of <code>flatMap</code> slightly in order to get much of the utility of <code>flatMap</code> without running in to our impasse when encoding. In our ill-fated attempt at implementing <code>flatMap</code>, we were short a value of <code>A</code>. Hence, we can ask the caller to provide the <code>A</code> value. A particularly useful way of doing so is changing the return type from <code>Codec[B]</code> to <code>Codec[(A, B)]</code>.</p>

<p>This has implications on both decoding and encoding &ndash; when decoding, we need to return the decoded <code>A</code> in the overall result instead of using it solely to generate the <code>Codec[B]</code>, whereas in encoding, we need to encode the input <code>A</code>, apply the function with the same <code>A</code> to create a <code>Codec[B]</code>, encode the input <code>B</code>, and finally concatenate the encoded forms of <code>A</code> and <code>B</code>. The signature is the same as <code>flatMap</code> except the result type is <code>Codec[(A, B)]</code> instead of <code>Codec[B]</code> &ndash; so for now, let&rsquo;s call this <code>flatZip</code> since it zips <code>A</code> and <code>B</code> in to a tuple.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Encoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">flatZip</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">sizeBound</span><span class="o">.</span><span class="n">atLeast</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">bres</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span>
</span><span class='line'>        <span class="n">bres</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">encA</span> <span class="k">&lt;-</span> <span class="n">self</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>      <span class="n">codecB</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>      <span class="n">encB</span> <span class="k">&lt;-</span> <span class="n">codecB</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">encA</span> <span class="o">++</span> <span class="n">encB</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Another solution to the <code>flatMap</code> dilemma is keeping the return type as <code>Codec[B]</code> but adding another parameter to the method that lets us materialize an <code>A</code> from what we have &ndash; namely, a <code>B</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Encoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">consume</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">sizeBound</span><span class="o">.</span><span class="n">atLeast</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">encA</span> <span class="k">&lt;-</span> <span class="n">self</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>        <span class="n">codecB</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>        <span class="n">encB</span> <span class="k">&lt;-</span> <span class="n">codecB</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">yield</span> <span class="n">encA</span> <span class="o">++</span> <span class="n">encB</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>One interesting use case for <code>consume</code> is handling header fields whose values are derived from the body. For instance, see <a href="https://github.com/scodec/scodec/blob/2d790190617b8025ce22c7c9f041f1a7a52a8d84/shared/src/test/scala/scodec/examples/ProductsExample.scala#L86-L103">this example from scodec</a>.</p>

<p>An interesting property of these methods is that they can be implemented in terms of one another, as long as we have the <code>xmap</code> operation.</p>

<ul>
<li><code>consume(f)(g) == flatZip(f).xmap[B](ab =&gt; ab._2)(b =&gt; (g(b), b))</code></li>
<li><code>flatZip(f) == consume(a =&gt; f(a).xmap[(A, B)](b =&gt; (a, b))(ab =&gt; ab._2))(ab =&gt; ab._1)</code></li>
</ul>


<p>The scodec library provides both of these methods, as they are useful in different scenarios. However, these identities show that they are just different formulations of the same concept.</p>

<h3>A note on naming</h3>

<p>The <code>flatZip</code> name leaves a lot to be desired. We selected it based on an appeal to how the method is <code>flatMap</code>-like in signature but returns a tuple &ndash; zipping the <code>A</code> and <code>B</code>. <code>flatMapAndZip</code> is way too long and a bit deceiving, as it implies that the operation is the result of composing zipping with <code>flatMap</code>. Additionally, we are only really zipping on the decoder side &ndash; when encoding, the user is passing the tuple to us. Zip describes the action that builds the tuple, but it would be clearer to describe the tuple itself. Using <code>product</code> to refer to the product type <code>(A, B)</code>, we could call this operation <code>flatMapProduct</code>.</p>

<p>The <code>consume</code> name could also be improved upon. For starters, it is evocative. Worse, the rationale for its name applies equally well when using <code>consume</code> as an alias for <code>flatMap</code>. Re-examining the signature shows us that <code>consume</code> is like <code>flatMap</code> but takes an extra parameter, <code>B =&gt; A</code>. There doesn&rsquo;t seem to be much help in naming there. Instead, let&rsquo;s use our identity to help name the operation. We&rsquo;ve shown that <code>consume</code> can be written in terms of <code>flatMapProduct</code> and <code>xmap</code>. Hence, <code>consume</code> is like an invariant version of the (covariant) <code>flatMap</code>. Informed by the fact that we use <code>xmap</code> as the invariant form of the (covariant) <code>map</code> method, we&rsquo;ll call this operation <code>xflatMap</code>.</p>

<p>Knowing that <code>flatMapProduct</code> depends on <code>xmap</code>, let&rsquo;s use the same convention there as well and call it <code>xflatMapProduct</code>.</p>

<p>Naming is hard.</p>

<h2>Generalizing</h2>

<p>Let&rsquo;s extract a type class for this operation. Here, we&rsquo;ll pick <code>xflatMap</code> as the primary operation and define <code>xflatMapProduct</code> in terms of <code>xflatMap</code>, but the inverse would be equally useful. Let&rsquo;s also assume we have an invariant functor type class available:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">InvariantFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">xflatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">xflatMapProduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">xflatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)](</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">B</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)](</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))(</span><span class="n">ab</span> <span class="k">=&gt;</span> <span class="n">ab</span><span class="o">.</span><span class="n">_2</span><span class="o">))(</span><span class="n">ab</span> <span class="k">=&gt;</span> <span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What laws can we write that govern the behavior of <code>xflatMap</code>? We could use the same laws as the normal <code>FlatMap</code> type class adjusted for the extra <code>g</code> parameter &ndash; namely, that <code>xflatMap</code> is associative.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">xflatMapAssociativity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
</span><span class='line'>  <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">],</span> <span class="n">gi</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="n">B</span>
</span><span class='line'><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)(</span><span class="n">fi</span><span class="o">))(</span><span class="n">g</span><span class="o">)(</span><span class="n">gi</span><span class="o">)</span> <span class="o">==</span>
</span><span class='line'>    <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">g</span><span class="o">)(</span><span class="n">gi</span><span class="o">))(</span><span class="n">gi</span> <span class="n">andThen</span> <span class="n">fi</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Parallels with <code>FlatMap</code></h3>

<p>The (covariant) <code>FlatMap</code> type class corresponds to <code>InvariantFlatMap</code> in the same way that (covariant) <code>Functor</code> corresponds to <code>InvariantFunctor</code>. For example, any <code>FlatMap</code> instance gives rise to an <code>InvariantFlatMap</code> instance which simply ignores the <code>g</code> parameter.</p>

<p>What about <code>xflatMapProduct</code> though? There&rsquo;s nothing to remove or ignore in its signature, so how can there be a correspondence to a covariant equivalent? The covariant equivalent of <code>xflatMapProduct</code> differs not in signature, but in implementation &ndash; specifically, it uses the covariant <code>map</code> instead of the invariant <code>xmap</code>. In fact, the covariant equivalent of <code>xflatMapProduct</code> is known as <code>mproduct</code> in Haskell &ndash; short for &ldquo;monad product&rdquo;, which is interesting because it does not rely on a full monad struture, but rather, only the structure of <code>FlatMap</code>/<code>Bind</code>. Naming is hard. (To be fair, <code>mproduct</code> exists in the Haskell standard library, which does not include the <code>Bind</code> type class.)</p>

<h2>Further Generalization with Fast and Loose Reasoning</h2>

<p>Building off these correspondences, can we create an <code>InvariantMonad</code> type class by adding a <code>pure</code> method to an <code>InvariantFunctor</code>?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>With the associativity law inherited from <code>InvariantFlatMap</code> along with a left and right identity law:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">invariantMonadLeftIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">f</span><span class="o">)(</span><span class="n">fi</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">invariantMonadRightIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">identity</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can now port arbitrary functions that work with monads to work with invariant monads &ndash; compensating for the extra inverse function as appropriate.</p>

<h2>Parting Thoughts</h2>

<p>Starting with a concrete example from scodec, we allowed the type system to guide us in the development of <code>flatZip</code> and <code>consume</code>. By generalizing the resulting operations, we were able to focus on the structure, with no implied meaning from binary serialization. Once we realized that we had build an invariant form of <code>FlatMap</code>, we were able to use loose reasoning based on correspondences with familiar type classes to develop an invariant form of <code>Monad</code>.</p>

<p>Continuously shifting between working with concrete types and working with minimally expressive type classes, allowing the findings from each style to inform the work in the opposite style, is a powerful technique in API development.</p>

<p>Further work will focus on development of an <code>InvariantApplicative</code> type class, along with finding more applications of these invariant type classes in scodec.</p>

<h2>Acknowledgements</h2>

<p>Special thanks to Paul Chiusano for some thoughtful discussion of these topics.</p>
</div>


<div class="meta">
	<div class="date">




Jun 18th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scodec/'>scodec</a>


</div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		<a class="addthis_button_tweet"></a>
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    Michael Pilquist

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'liftM';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://mpilquist.github.io/blog/2015/06/18/invariant-shadows/';
        var disqus_url = 'http://mpilquist.github.io/blog/2015/06/18/invariant-shadows/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-41236326-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>