
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>mpilquist.github.io</title>
	<meta name="author" content="Michael Pilquist">

	
	<meta name="description" content=" Talk given at Scala World in Penrith, UK. Slides available on SpeakerDeck. Read on &rarr; Sep 21st, 2015 talks ">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="mpilquist.github.io" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">mpilquist.github.io</a></h1>
<nav id="main-nav"><ul class="main">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories/talks">Talks</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories/talks">Talks</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:mpilquist.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		<a class="google" href="https://plus.google.com/106335582774991536012?rel=author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/mpilquist" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/mpilquist" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:mpilquist.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/21/scalaworld/">
		
			Practical Binary With Scodec: Applying Typelevel Programming and Shapeless to the Mundane</a>
	</h2>
	<div class="entry-content">
		<p>Talk given at <a href="http://scala.world">Scala World</a> in Penrith, UK. Slides available on <a href="https://speakerdeck.com/mpilquist/practical-binary-with-scodec-and-shapeless">SpeakerDeck</a>.</p>


		
		<a href="/blog/2015/09/21/scalaworld/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Sep 21st, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/talks/'>talks</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/14/sbtb/">
		
			A Tour of Functional Structures via Scodec and Simulacrum</a>
	</h2>
	<div class="entry-content">
		<p>Talk given at <a href="http://scala.bythebay.io">Scala By The Bay 2015</a>. Slides available on <a href="https://speakerdeck.com/mpilquist/a-tour-of-functional-structures-via-scodec-and-simulacrum">SpeakerDeck</a>.</p>


		
		<a href="/blog/2015/08/14/sbtb/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 14th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/talks/'>talks</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/06/22/invariant-shadows-part-2/">
		
			Invariant Shadows - Part 2: Monoidals</a>
	</h2>
	<div class="entry-content">
		<p>In the <a href="/blog/2015/06/18/invariant-shadows/">last post</a>, we built type classes for a subset of invariant functors &ndash; namely, type classes that drew inspiration from the covariant <code>FlatMap</code> and <code>Monad</code>. In this article, we&rsquo;ll explore invariant shadows of the type classes supporting applicative functors.</p>

<p>Disclaimer: I am not a category theorist, and in both the previous article and this article, I use fairly loose reasoning to explore these type classes. Corrections are welcome.</p>

<p>First, let&rsquo;s review the definition of an applicative functor, using a type class hierachy similar to the one used in <a href="https://github.com/non/cats">Cats</a>. (These examples are simplified versions of the definitions in the Cats codebase.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">ff</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Along with laws:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">applyComposition</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fab</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">],</span> <span class="n">fbc</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span> <span class="k">=&gt;</span> <span class="kt">C</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">compose</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span> <span class="o">=&gt;</span> <span class="kt">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=</span> <span class="k">_</span><span class="o">.</span><span class="n">compose</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">fab</span><span class="o">))(</span><span class="n">fbc</span><span class="o">)</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">fab</span><span class="o">)(</span><span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fbc</span><span class="o">)(</span><span class="n">compose</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">applicativeIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">((</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">))</span> <span class="o">==</span> <span class="n">fa</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">applicativeHomomorphism</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">))</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">applicativeInterchange</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">ff</span><span class="o">)</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">ff</span><span class="o">)(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">((</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">applicativeMap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span> <span class="o">==</span> <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Applicative[Codec]</h3>

<p>Can we define an <code>Applicative[Codec]</code> instance?  We&rsquo;ve previously seen how <code>Codec</code> has an invariant functor instance but not a covariant functor instance. As such, we can rule out an <code>Applicative[Codec]</code>, for if we could define such an instance, it would give rise to a <code>Functor[Codec]</code>. Regardless, let&rsquo;s try to implement such an instance, as it is illustrative.</p>

<p>In the last article, it was implied that we can implement pure for <code>Codec</code>. Here&rsquo;s an implementation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="nc">SizeBound</span><span class="o">.</span><span class="n">exact</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Attempt</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">BitVector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Attempt</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">DecodeResult</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The encode operation always returns an empty vector, while the decode operation always returns the full input as the remainder and returns the pure value as the decoded value.</p>

<p>How about <code>ap</code>?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ca</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cf</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="nc">SizeBound</span><span class="o">.</span><span class="n">unknown</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">decA</span> <span class="k">&lt;-</span> <span class="nc">DecodingContext</span><span class="o">(</span><span class="n">ca</span><span class="o">)</span>
</span><span class='line'>    <span class="n">defF</span> <span class="k">&lt;-</span> <span class="nc">DecodingContext</span><span class="o">(</span><span class="n">cb</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">decF</span><span class="o">(</span><span class="n">decA</span><span class="o">)).</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">???</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The decode case is easy enough to define using the <code>DecodingContext</code> type from scodec, which is equivalent to a <code>StateT[Attempt, BitVector, ?]</code> monad transformer stack, threading the remainder of each decode as the state value. We encounter an impasse in <code>encode</code> though. We could try to add a <code>B =&gt; A</code> function, though it is not obvious as to how that would help. Instead, we can use an alternative form of applicative functors known as monoidal functors.</p>

<h2>Monoidal Functors</h2>

<p><a href="https://wiki.haskell.org/Typeclassopedia#Alternative_formulation">(Lax) monoidal functors</a> are an alternative form of applicative functors &ndash; similar to how monads can be represented with either <code>pure</code> and <code>flatMap</code> or <code>unit</code>, <code>flatten</code> (aka <code>join</code>), and <code>map</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Instead of defining <code>pure</code> and <code>ap</code>, monoidal functors are defined in terms of <code>unit</code>, <code>zip</code>, and <code>map</code>. Note that in the standard/typical definition, <code>map</code> is derived from <code>pure</code> and <code>ap</code> but in the monoidal definition, <code>map</code> is left abstract.</p>

<p>The laws for monoidal functors are the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Iso</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">implicit</span> <span class="k">class</span> <span class="nc">IsoOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">~=[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">iso</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="n">b</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">monoidalLeftIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">F</span><span class="o">[(</span><span class="kt">Unit</span>, <span class="kt">A</span><span class="o">)]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">unit</span><span class="o">,</span> <span class="n">fa</span><span class="o">)</span> <span class="o">~=</span> <span class="n">fa</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">monoidalRightIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">Unit</span><span class="o">)]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span> <span class="o">~=</span> <span class="n">fa</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">monoidalAssociativity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">fc</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="o">(</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">))]</span>, <span class="kt">F</span><span class="o">[((</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)</span>, <span class="kt">C</span><span class="o">)]])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fb</span><span class="o">,</span> <span class="n">fc</span><span class="o">))</span> <span class="o">~=</span> <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">fb</span><span class="o">),</span> <span class="n">fc</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The identity laws state that zipping a value with the unit value yields the original value, ignoring the tuple structure. The associativity law requires <code>zip</code> to be associative, again ignoring the tuple structure. Here, like in the Typeclassopedia definition, we defer the equality checking to an isomorphism that ignores the unwanted structure.</p>

<p>We could further generalize this type class by removing the requirement for the <code>unit</code> and <code>map</code> operations, leaving simply <code>zip</code> along with the associativity law &ndash; this is exactly what Scalaz has done with the <code>scalaz.Zip</code> type class.</p>

<h3>Converting applicative forms</h3>

<p>We can convert any applicative functor to a monoidal functor and vice-versa:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">applicativeToMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(())</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ap</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">monoidalToApplicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">unit</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">ff</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">ff</span><span class="o">))</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Monoidal[Codec]</h2>

<p>Let&rsquo;s try to implement a <code>Monoidal</code> instance for <code>Codec</code>.</p>

<p>The definition of <code>unit</code> looks very similar to the definition of <code>pure</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="nc">SizeBound</span><span class="o">.</span><span class="n">exact</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Attempt</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">BitVector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Attempt</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">DecodeResult</span><span class="o">((),</span> <span class="n">b</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let&rsquo;s try to implement <code>zip</code> &ndash; note that we should not be able to, as we know <code>Codec</code> doesn&rsquo;t have a covariant functor.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ca</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">cb</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">sizeBound</span> <span class="o">+</span> <span class="n">cb</span><span class="o">.</span><span class="n">sizeBound</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">DecodingContext</span><span class="o">(</span><span class="n">ca</span><span class="o">)</span>
</span><span class='line'>    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">DecodingContext</span><span class="o">(</span><span class="n">cb</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)).</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">encA</span> <span class="k">&lt;-</span> <span class="n">ca</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">encB</span> <span class="k">&lt;-</span> <span class="n">cb</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">encA</span> <span class="o">++</span> <span class="n">encB</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wait, so what are we missing? We have an implementation of <code>unit</code> and <code>zip</code> and yet we know we can&rsquo;t have a lawful <code>Monoidal[Codec]</code> instance due to the fact that there&rsquo;s no covariant functor for <code>Codec</code>. Monoidal functors have <em>three</em> abstract operations though, not two (like <code>Applicative</code>) &ndash; <code>unit</code>, <code>zip</code>, and <code>map</code>. So in order to have a monoidal functor for <code>Codec</code>, we need to define <code>map</code>, which we know we can&rsquo;t do!</p>

<p>However, we do have <code>xmap</code>. What happens if we pair <code>xmap</code> with <code>unit</code> and <code>zip</code>?</p>

<h2>Invariant monoidal functors</h2>

<p>Let&rsquo;s define a new invariant shadow of <code>Monoidal</code> that extends <code>InvariantFunctor</code> instead of <code>Functor</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can also port the laws from lax monoidal functors, which are identical except for requiring an <code>InvariantMonoidal</code> instance instead of a <code>Monoidal</code> instance:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">xmonoidalLeftIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">F</span><span class="o">[(</span><span class="kt">Unit</span>, <span class="kt">A</span><span class="o">)]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">unit</span><span class="o">,</span> <span class="n">fa</span><span class="o">)</span> <span class="o">~=</span> <span class="n">fa</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">xmonoidalRightIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">Unit</span><span class="o">)]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span> <span class="o">~=</span> <span class="n">fa</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">xmonoidalAssociativity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">fc</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">iso</span><span class="k">:</span> <span class="kt">Iso</span><span class="o">[</span><span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="o">(</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">))]</span>, <span class="kt">F</span><span class="o">[((</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)</span>, <span class="kt">C</span><span class="o">)]])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fb</span><span class="o">,</span> <span class="n">fc</span><span class="o">))</span> <span class="o">~=</span> <span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">fb</span><span class="o">),</span> <span class="n">fc</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Deriving an <code>InvariantMonoidal</code> from an <code>InvariantMonad</code></h3>

<p>In the same way that a monad yields two monoidal functors (or two applicative functors) &ndash; one that evaluates <code>F[A]</code> first and <code>F[B]</code> second, and another which evaluates in the reverse order &ndash; an invariant monad gives rise to two invariant monoidal functors. For example, the following implementation evaluates the <code>F[A]</code> first and the <code>F[B]</code> second:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">xmonadToXmonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(())</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">xmap</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))(</span><span class="n">ab</span> <span class="k">=&gt;</span> <span class="n">ab</span><span class="o">.</span><span class="n">_2</span><span class="o">))(</span><span class="n">ab</span> <span class="k">=&gt;</span> <span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">xmap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)(</span><span class="n">g</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Sharing unit/zip</h3>

<p>Because the invariant monoidal differs from the covariant monoidal only in the defintion of <code>xmap</code>/<code>map</code>, we could extract a type class that captures the signature of <code>unit</code> and <code>zip</code> and the laws that govern their interaction.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">MonoidalBase</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">trait</span> <span class="nc">Monoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">MonoidalBase</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</span><span class='line'><span class="k">trait</span> <span class="nc">InvariantMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">MonoidalBase</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Applicability to Codec</h2>

<p>In the last article, we saw that <code>Codec</code> supported both <code>flatZip</code> and <code>consume</code>, and how those methods exist due to the invariant monad structure of <code>Codec</code>. In fact, those methods both existed <em>before</em> the invariant monad structure was extracted. Is the same true for <code>unit</code> and <code>zip</code>? That is, do those methods exist under some other name, their existence justified by their usefulness in binary codec creation, rather than satisfying a type class definition?</p>

<p>It turns out that both of these operations do exist already. The <code>unit</code> operation is provided by <code>scodec.codecs.ignore(0L)</code>, which returns a <code>Codec[Unit]</code> that encodes an empty bit vector. The <code>zip</code> operation is provided by the <code>pairedWith</code> method on codec &ndash; which has the operator alias <code>~</code>.</p>

<p>We did not provide an invariant shadow of applicative functors, though that is worth exploring, perhaps in a future article.</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Jun 22nd, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scodec-scala/'>scodec,scala</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/06/18/invariant-shadows/">
		
			Invariant Shadows</a>
	</h2>
	<div class="entry-content">
		<p>A common use case when working with binary protocols is decoding a value and then using the decoded value to determine how to decode the remaining bits. For example, consider a simple framing structure, made up of a 2-byte big endian unsigned integer field followed by <code>n</code> bytes, where <code>n</code> is the value in the first field. In order to decode this structure, we need to first decode the 2-byte size field, then use the decoded size to take that number of bytes from the remainder.</p>

<p>This can be represented with <a href="http://scodec.org">scodec</a> like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scodec._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scodec.bits._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scodec.codecs._</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">decoder</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">ByteVector</span><span class="o">]</span> <span class="k">=</span> <span class="n">uint16</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="n">size</span> <span class="k">=&gt;</span> <span class="n">bytes</span><span class="o">(</span><span class="n">size</span> <span class="o">*</span> <span class="mi">8L</span><span class="o">)</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, we used <code>flatMap</code> to express the dependency between <code>uint16: Codec[Int]</code> and the bytes decoder. However, <code>flatMap</code> on <code>Codec</code> returns
a <code>Decoder[B]</code>, not a <code>Codec[B]</code>, so by using <code>flatMap</code>, we lose the ability to encode.</p>

<p>It turns out that it is impossible to define <code>flatMap</code> for <code>Codec</code> with the expected signature. Consider this attempt:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Encoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">sizeBound</span><span class="o">.</span><span class="n">atLeast</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>      <span class="o">???</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The implementation of <code>decode</code> is straightforward, but we arrive at an impasse when trying to implement <code>encode</code>. We have a <code>Codec[A]</code>, a function <code>A =&gt; Codec[B]</code> and a value of type <code>B</code>. We cannot use the <code>Codec[A]</code> to encode unless we have an <code>A</code>, and we cannot get access to a <code>Codec[B]</code> unless we have an <code>A</code> to apply to the function. Hence, we cannot implement <code>flatMap</code> on <code>Codec</code> &ndash; meaning that there is no monad for <code>Codec</code>!</p>

<p>So how were we able to call <code>flatMap</code> on <code>Codec</code> in our first example? That worked because <code>Decoder</code> defines a <code>flatMap</code> method like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Because <code>Codec</code> extends from <code>Decoder</code>, it inherits this definition of <code>flatMap</code>, which is why flat mapping a <code>Codec</code> results in a <code>Decoder</code>.</p>

<p>Nonetheless, we can change the signature of <code>flatMap</code> slightly in order to get much of the utility of <code>flatMap</code> without running in to our impasse when encoding. In our ill-fated attempt at implementing <code>flatMap</code>, we were short a value of <code>A</code>. Hence, we can ask the caller to provide the <code>A</code> value. A particularly useful way of doing so is changing the return type from <code>Codec[B]</code> to <code>Codec[(A, B)]</code>.</p>

<p>This has implications on both decoding and encoding &ndash; when decoding, we need to return the decoded <code>A</code> in the overall result instead of using it solely to generate the <code>Codec[B]</code>, whereas in encoding, we need to encode the input <code>A</code>, apply the function with the same <code>A</code> to create a <code>Codec[B]</code>, encode the input <code>B</code>, and finally concatenate the encoded forms of <code>A</code> and <code>B</code>. The signature is the same as <code>flatMap</code> except the result type is <code>Codec[(A, B)]</code> instead of <code>Codec[B]</code> &ndash; so for now, let&rsquo;s call this <code>flatZip</code> since it zips <code>A</code> and <code>B</code> in to a tuple.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Encoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">flatZip</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">sizeBound</span><span class="o">.</span><span class="n">atLeast</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">bres</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span>
</span><span class='line'>        <span class="n">bres</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">encA</span> <span class="k">&lt;-</span> <span class="n">self</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>      <span class="n">codecB</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>      <span class="n">encB</span> <span class="k">&lt;-</span> <span class="n">codecB</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">ab</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">encA</span> <span class="o">++</span> <span class="n">encB</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Another solution to the <code>flatMap</code> dilemma is keeping the return type as <code>Codec[B]</code> but adding another parameter to the method that lets us materialize an <code>A</code> from what we have &ndash; namely, a <code>B</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Encoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">consume</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Codec</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sizeBound</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">sizeBound</span><span class="o">.</span><span class="n">atLeast</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BitVector</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">DecodeResult</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">self</span><span class="o">.</span><span class="n">decode</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">decode</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">remainder</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Attempt</span><span class="o">[</span><span class="kt">BitVector</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">encA</span> <span class="k">&lt;-</span> <span class="n">self</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>        <span class="n">codecB</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>        <span class="n">encB</span> <span class="k">&lt;-</span> <span class="n">codecB</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">yield</span> <span class="n">encA</span> <span class="o">++</span> <span class="n">encB</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>One interesting use case for <code>consume</code> is handling header fields whose values are derived from the body. For instance, see <a href="https://github.com/scodec/scodec/blob/2d790190617b8025ce22c7c9f041f1a7a52a8d84/shared/src/test/scala/scodec/examples/ProductsExample.scala#L86-L103">this example from scodec</a>.</p>

<p>An interesting property of these methods is that they can be implemented in terms of one another, as long as we have the <code>xmap</code> operation.</p>

<ul>
<li><code>consume(f)(g) == flatZip(f).xmap[B](ab =&gt; ab._2)(b =&gt; (g(b), b))</code></li>
<li><code>flatZip(f) == consume(a =&gt; f(a).xmap[(A, B)](b =&gt; (a, b))(ab =&gt; ab._2))(ab =&gt; ab._1)</code></li>
</ul>


<p>The scodec library provides both of these methods, as they are useful in different scenarios. However, these identities show that they are just different formulations of the same concept.</p>

<h3>A note on naming</h3>

<p>The <code>flatZip</code> name leaves a lot to be desired. We selected it based on an appeal to how the method is <code>flatMap</code>-like in signature but returns a tuple &ndash; zipping the <code>A</code> and <code>B</code>. <code>flatMapAndZip</code> is way too long and a bit deceiving, as it implies that the operation is the result of composing zipping with <code>flatMap</code>. Additionally, we are only really zipping on the decoder side &ndash; when encoding, the user is passing the tuple to us. Zip describes the action that builds the tuple, but it would be clearer to describe the tuple itself. Using <code>product</code> to refer to the product type <code>(A, B)</code>, we could call this operation <code>flatMapProduct</code>.</p>

<p>The <code>consume</code> name could also be improved upon. For starters, it is evocative. Worse, the rationale for its name applies equally well when using <code>consume</code> as an alias for <code>flatMap</code>. Re-examining the signature shows us that <code>consume</code> is like <code>flatMap</code> but takes an extra parameter, <code>B =&gt; A</code>. There doesn&rsquo;t seem to be much help in naming there. Instead, let&rsquo;s use our identity to help name the operation. We&rsquo;ve shown that <code>consume</code> can be written in terms of <code>flatMapProduct</code> and <code>xmap</code>. Hence, <code>consume</code> is like an invariant version of the (covariant) <code>flatMap</code>. Informed by the fact that we use <code>xmap</code> as the invariant form of the (covariant) <code>map</code> method, we&rsquo;ll call this operation <code>xflatMap</code>.</p>

<p>Knowing that <code>flatMapProduct</code> depends on <code>xmap</code>, let&rsquo;s use the same convention there as well and call it <code>xflatMapProduct</code>.</p>

<p>Naming is hard.</p>

<h2>Generalizing</h2>

<p>Let&rsquo;s extract a type class for this operation. Here, we&rsquo;ll pick <code>xflatMap</code> as the primary operation and define <code>xflatMapProduct</code> in terms of <code>xflatMap</code>, but the inverse would be equally useful. Let&rsquo;s also assume we have an invariant functor type class available:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">InvariantFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">xflatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">xflatMapProduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">xflatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)](</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">B</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)](</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))(</span><span class="n">ab</span> <span class="k">=&gt;</span> <span class="n">ab</span><span class="o">.</span><span class="n">_2</span><span class="o">))(</span><span class="n">ab</span> <span class="k">=&gt;</span> <span class="n">ab</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What laws can we write that govern the behavior of <code>xflatMap</code>? We could use the same laws as the normal <code>FlatMap</code> type class adjusted for the extra <code>g</code> parameter &ndash; namely, that <code>xflatMap</code> is associative.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">xflatMapAssociativity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
</span><span class='line'>  <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">],</span> <span class="n">gi</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="n">B</span>
</span><span class='line'><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)(</span><span class="n">fi</span><span class="o">))(</span><span class="n">g</span><span class="o">)(</span><span class="n">gi</span><span class="o">)</span> <span class="o">==</span>
</span><span class='line'>    <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">g</span><span class="o">)(</span><span class="n">gi</span><span class="o">))(</span><span class="n">gi</span> <span class="n">andThen</span> <span class="n">fi</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Parallels with <code>FlatMap</code></h3>

<p>The (covariant) <code>FlatMap</code> type class corresponds to <code>InvariantFlatMap</code> in the same way that (covariant) <code>Functor</code> corresponds to <code>InvariantFunctor</code>. For example, any <code>FlatMap</code> instance gives rise to an <code>InvariantFlatMap</code> instance which simply ignores the <code>g</code> parameter.</p>

<p>What about <code>xflatMapProduct</code> though? There&rsquo;s nothing to remove or ignore in its signature, so how can there be a correspondence to a covariant equivalent? The covariant equivalent of <code>xflatMapProduct</code> differs not in signature, but in implementation &ndash; specifically, it uses the covariant <code>map</code> instead of the invariant <code>xmap</code>. In fact, the covariant equivalent of <code>xflatMapProduct</code> is known as <code>mproduct</code> in Haskell &ndash; short for &ldquo;monad product&rdquo;, which is interesting because it does not rely on a full monad struture, but rather, only the structure of <code>FlatMap</code>/<code>Bind</code>. Naming is hard. (To be fair, <code>mproduct</code> exists in the Haskell standard library, which does not include the <code>Bind</code> type class.)</p>

<h2>Further Generalization with Fast and Loose Reasoning</h2>

<p>Building off these correspondences, can we create an <code>InvariantMonad</code> type class by adding a <code>pure</code> method to an <code>InvariantFunctor</code>?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFlatMap</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>With the associativity law inherited from <code>InvariantFlatMap</code> along with a left and right identity law:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">invariantMonadLeftIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">f</span><span class="o">)(</span><span class="n">fi</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">invariantMonadRightIdentity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">InvariantMonad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">F</span><span class="o">.</span><span class="n">xflatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">identity</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can now port arbitrary functions that work with monads to work with invariant monads &ndash; compensating for the extra inverse function as appropriate.</p>

<h2>Parting Thoughts</h2>

<p>Starting with a concrete example from scodec, we allowed the type system to guide us in the development of <code>flatZip</code> and <code>consume</code>. By generalizing the resulting operations, we were able to focus on the structure, with no implied meaning from binary serialization. Once we realized that we had build an invariant form of <code>FlatMap</code>, we were able to use loose reasoning based on correspondences with familiar type classes to develop an invariant form of <code>Monad</code>.</p>

<p>Continuously shifting between working with concrete types and working with minimally expressive type classes, allowing the findings from each style to inform the work in the opposite style, is a powerful technique in API development.</p>

<p>Further work will focus on development of an <code>InvariantApplicative</code> type class, along with finding more applications of these invariant type classes in scodec.</p>

<h2>Acknowledgements</h2>

<p>Special thanks to Paul Chiusano for some thoughtful discussion of these topics.</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Jun 18th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scodec/'>scodec</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/04/22/intro-to-shapeless/">
		
			Introduction to Generic Programming With Shapeless, With Applications From Scodec</a>
	</h2>
	<div class="entry-content">
		<p>Talk given at <a href="http://www.meetup.com/scala-phase/">PHASE</a>. Slides available on <a href="https://speakerdeck.com/mpilquist/introduction-to-shapeless-with-applications-from-scodec">SpeakerDeck</a>.</p>


		
		<a href="/blog/2015/04/22/intro-to-shapeless/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 22nd, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/talks/'>talks</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/04/22/functional-structures/">
		
			Functional Structures in Scala Screencast Series</a>
	</h2>
	<div class="entry-content">
		<p>Informal talk series that presents the major functional programming type classes in Scala.</p>

<p>Talks are intended to complement the fantastic Functional Programming in Scala by Paul Chiusano and Rúnar Bjarnason (<a href="http://www.manning.com/bjarnason/">http://www.manning.com/bjarnason/</a>).</p>

<p>Given the informal nature of the talks, there are mistakes. Errata will be posted on each talk in the descriptions.</p>


		
		<a href="/blog/2015/04/22/functional-structures/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 22nd, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/talks/'>talks</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/27/variance/">
		
			Explorations in Variance</a>
	</h2>
	<div class="entry-content">
		<p>A talk given at Philly Lambda on 5/27/2014 exploring subtyping variance and functor variance, including:</p>

<ul>
<li>A review of subtyping invariance</li>
<li>Functor typeclass</li>
<li>Contravariant functor typeclass</li>
<li>Invariant functor typeclass</li>
<li>Profunctor typeclass</li>
<li>Correspondence between subtyping variance and functor variance</li>
</ul>


<p>Slides and code available on <a href="https://github.com/mpilquist/variance-explorations">GitHub</a>.</p>

<p>Slides available on <a href="https://speakerdeck.com/mpilquist/explorations-in-variance">SpeakerDeck</a>.</p>


		
		<a href="/blog/2014/05/27/variance/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




May 27th, 2014</div>
	<div class="tags">


	<a class='category' href='/blog/categories/talks/'>talks</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/06/09/scodec-part-3/">
		
			Scodec - Part 3 - Shapeless</a>
	</h2>
	<div class="entry-content">
		<p>This is part 3 of a series of posts about <a href="http://github.com/mpilquist/scodec/">scodec</a>. In <a href="/blog/2013/06/01/scodec-part-2/">Part 2</a>, we saw how to create a <code>Codec[A]</code> and xmap it in to a <code>Codec[B]</code>. In this post, we&rsquo;ll show how to use <a href="http://github.com/milessabin/shapeless/">Shapeless</a> to perform automatic xmapping to case classes.</p>


		
		<a href="/blog/2013/06/09/scodec-part-3/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Jun 9th, 2013</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scodec/'>scodec</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/06/01/scodec-part-2/">
		
			Scodec - Part 2 - Conversions</a>
	</h2>
	<div class="entry-content">
		<p>In <a href="/blog/2013/05/27/scodec-intro/">Part 1</a>, we looked at the codec trait and a way to create a <code>Codec[(A, B)]</code> out of a <code>Codec[A]</code> and a <code>Codec[B]</code>. In this post, we&rsquo;ll look at converting a <code>Codec[A]</code> to a <code>Codec[B]</code> using a type driven approach and we&rsquo;ll get our feet wet with some category theory.</p>


		
		<a href="/blog/2013/06/01/scodec-part-2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Jun 1st, 2013</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scodec/'>scodec</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/05/27/scodec-intro/">
		
			Scodec - Part 1 - Introduction</a>
	</h2>
	<div class="entry-content">
		<p>I recently started the <a href="http://github.com/mpilquist/scodec">scodec</a> project to simplify handling of binary data in Scala. From the project page:</p>

<blockquote><p>This library focuses on contract-first and pure functional encoding and decoding of binary data.
The following design constraints are considered:</p>

<ul>
<li>Binary structure should mirror protocol definitions and be self-evident under casual reading</li>
<li>Mapping binary structures to types should be statically verified</li>
<li>Encoding and decoding should be purely functional</li>
<li>Failures in encoding and decoding should provide descriptive errors</li>
<li>Compiler plugin should not be used</li>
</ul>


<p>As a result, the library is implemented as a combinator based DSL.
Performance is considered but yields to the above design constraints.</p></blockquote>

<p>This article will introduce some of the main abstractions in scodec and discuss some of the design decisions. Subsequent articles will discuss more interesting parts of scodec, including invariant functors and use of <a href="http://github.com/milessabing/shapeless">Shapeless</a>.</p>


		
		<a href="/blog/2013/05/27/scodec-intro/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




May 27th, 2013</div>
	<div class="tags">


	<a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scodec/'>scodec</a>


</div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Michael Pilquist

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'liftM';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-41236326-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>