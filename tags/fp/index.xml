<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fp on mpilquist</title>
    <link>https://mpilquist.github.io/tags/fp/index.xml</link>
    <description>Recent content in Fp on mpilquist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012 - 2017 Michael Pilquist</copyright>
    <atom:link href="https://mpilquist.github.io/tags/fp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Compositional Streaming with FS2</title>
      <link>https://mpilquist.github.io/blog/2016/11/13/fs2/</link>
      <pubDate>Sun, 13 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2016/11/13/fs2/</guid>
      <description>&lt;p&gt;Talk given at &lt;a href=&#34;http://scala.bythebay.io&#34;&gt;Scalae By The Bay 2016&lt;/a&gt;. Slides available on &lt;a href=&#34;https://speakerdeck.com/mpilquist/compositional-streaming-with-fs2&#34;&gt;SpeakerDeck&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class=&#34;video-container&#34;&gt;
  &lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/oFk8-a1FSP0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Intro to Functional Streams for Scala (FS2)</title>
      <link>https://mpilquist.github.io/blog/2016/05/20/fs2/</link>
      <pubDate>Fri, 20 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2016/05/20/fs2/</guid>
      <description>&lt;p&gt;Informal talk series that introduces Functional Streams for Scala (FS2).&lt;/p&gt;

&lt;p&gt;
&lt;div class=&#34;video-container&#34;&gt;
  &lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/cahvyadYfX8?list=PLFrwDVdSrYE6PVD_p6YQLAbNaEHagx9bW&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>From Simulacrum to Typeclassic</title>
      <link>https://mpilquist.github.io/blog/2016/03/02/simulacrum/</link>
      <pubDate>Wed, 02 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2016/03/02/simulacrum/</guid>
      <description>&lt;p&gt;Talk given at the &lt;a href=&#34;http://typelevel.org/event/2016-03-summit-philadelphia/&#34;&gt;Typelevel Summit Philadelphia&lt;/a&gt;. Slides available on &lt;a href=&#34;https://speakerdeck.com/mpilquist/from-simulacrum-to-typeclassic&#34;&gt;SpeakerDeck&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class=&#34;video-container&#34;&gt;
  &lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Crc2RHWrcLI&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Tour of Functional Structures via Scodec and Simulacrum</title>
      <link>https://mpilquist.github.io/blog/2015/08/14/sbtb/</link>
      <pubDate>Fri, 14 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2015/08/14/sbtb/</guid>
      <description>&lt;p&gt;Talk given at &lt;a href=&#34;http://scala.bythebay.io&#34;&gt;Scala By The Bay 2015&lt;/a&gt;. Slides available on &lt;a href=&#34;https://speakerdeck.com/mpilquist/a-tour-of-functional-structures-via-scodec-and-simulacrum&#34;&gt;SpeakerDeck&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;div class=&#34;video-container&#34;&gt;
  &lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/CtyzSZ3Z5_w&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Invariant Shadows - Part 2: Monoidals</title>
      <link>https://mpilquist.github.io/blog/2015/06/22/invariant-shadows-part-2/</link>
      <pubDate>Mon, 22 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2015/06/22/invariant-shadows-part-2/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;https://mpilquist.github.io/blog/2015/06/18/invariant-shadows/&#34;&gt;last post&lt;/a&gt;, we built type classes for a subset of invariant functors &amp;ndash; namely, type classes that drew inspiration from the covariant &lt;code&gt;FlatMap&lt;/code&gt; and &lt;code&gt;Monad&lt;/code&gt;. In this article, we&amp;rsquo;ll explore invariant shadows of the type classes supporting applicative functors.&lt;/p&gt;

&lt;p&gt;Disclaimer: I am not a category theorist, and in both the previous article and this article, I use fairly loose reasoning to explore these type classes. Corrections are welcome.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s review the definition of an applicative functor, using a type class hierachy similar to the one used in &lt;a href=&#34;https://github.com/non/cats&#34;&gt;Cats&lt;/a&gt;. (These examples are simplified versions of the definitions in the Cats codebase.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Apply[F[_]] extends Functor[F] {
  def ap[A, B](fa: F[A])(ff: F[A =&amp;gt; B]): F[B]
}

trait Applicative[F[_]] extends Apply[F] {
  def pure[A](a: A): F[A]
  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B] = ap(fa)(pure(f))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Along with laws:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def applyComposition[F[_], A, B, C](fa: F[A], fab: F[A =&amp;gt; B], fbc: F[B =&amp;gt; C])(implicit F: Apply[F]): Boolean = {
  val compose: (B =&amp;gt; C) =&amp;gt; (A =&amp;gt; B) =&amp;gt; (A =&amp;gt; C) = _.compose
  F.ap(F.ap(fa)(fab))(fbc) == F.ap(fa)(F.ap(fab)(F.map(fbc)(compose)))
}

def applicativeIdentity[F[_], A](fa: F[A])(implicit F: Applicative[F]): Boolean =
  F.ap(fa)(F.pure((a: A) =&amp;gt; a)) == fa

def applicativeHomomorphism[F[_], A, B](a: A, f: A =&amp;gt; B)(implicit F: Applicative[F]): Boolean =
  F.ap(F.pure(a))(F.pure(f)) == F.pure(f(a))

def applicativeInterchange[F[_], A, B](a: A, ff: F[A =&amp;gt; B])(implicit F: Applicative[F]): Boolean =
  F.ap(F.pure(a))(ff) == F.ap(ff)(F.pure((f: A =&amp;gt; B) =&amp;gt; f(a)))

def applicativeMap[F[_], A, B](fa: F[A], f: A =&amp;gt; B)(implicit F: Applicative[F]): Boolean =
  F.map(fa)(f) == F.ap(fa)(F.pure(f))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;applicative-codec&#34;&gt;Applicative[Codec]&lt;/h3&gt;

&lt;p&gt;Can we define an &lt;code&gt;Applicative[Codec]&lt;/code&gt; instance?  We&amp;rsquo;ve previously seen how &lt;code&gt;Codec&lt;/code&gt; has an invariant functor instance but not a covariant functor instance. As such, we can rule out an &lt;code&gt;Applicative[Codec]&lt;/code&gt;, for if we could define such an instance, it would give rise to a &lt;code&gt;Functor[Codec]&lt;/code&gt;. Regardless, let&amp;rsquo;s try to implement such an instance, as it is illustrative.&lt;/p&gt;

&lt;p&gt;In the last article, it was implied that we can implement pure for &lt;code&gt;Codec&lt;/code&gt;. Here&amp;rsquo;s an implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def pure[A](a: A): Codec[A] = new Codec[A] {
  def sizeBound = SizeBound.exact(0)
  def encode(a: A) = Attempt.successful(BitVector.empty)
  def decode(b: BitVector) = Attempt.successful(DecodeResult(a, b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The encode operation always returns an empty vector, while the decode operation always returns the full input as the remainder and returns the pure value as the decoded value.&lt;/p&gt;

&lt;p&gt;How about &lt;code&gt;ap&lt;/code&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def ap[A, B](ca: Codec[A])(cf: Codec[A =&amp;gt; B]): Codec[B] = new Codec[B] {
  def sizeBound = SizeBound.unknown
  def decode(b: BitVector) = (for {
    decA &amp;lt;- DecodingContext(ca)
    defF &amp;lt;- DecodingContext(cb)
  } yield decF(decA)).decode(b)
  def encode(b: B) = {
    ???
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The decode case is easy enough to define using the &lt;code&gt;DecodingContext&lt;/code&gt; type from scodec, which is equivalent to a &lt;code&gt;StateT[Attempt, BitVector, ?]&lt;/code&gt; monad transformer stack, threading the remainder of each decode as the state value. We encounter an impasse in &lt;code&gt;encode&lt;/code&gt; though. We could try to add a &lt;code&gt;B =&amp;gt; A&lt;/code&gt; function, though it is not obvious as to how that would help. Instead, we can use an alternative form of applicative functors known as monoidal functors.&lt;/p&gt;

&lt;h2 id=&#34;monoidal-functors&#34;&gt;Monoidal Functors&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.haskell.org/Typeclassopedia#Alternative_formulation&#34;&gt;(Lax) monoidal functors&lt;/a&gt; are an alternative form of applicative functors &amp;ndash; similar to how monads can be represented with either &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;unit&lt;/code&gt;, &lt;code&gt;flatten&lt;/code&gt; (aka &lt;code&gt;join&lt;/code&gt;), and &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Monoidal[F[_]] extends Functor[F] {
  def unit: F[Unit]
  def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of defining &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;ap&lt;/code&gt;, monoidal functors are defined in terms of &lt;code&gt;unit&lt;/code&gt;, &lt;code&gt;zip&lt;/code&gt;, and &lt;code&gt;map&lt;/code&gt;. Note that in the standard/typical definition, &lt;code&gt;map&lt;/code&gt; is derived from &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;ap&lt;/code&gt; but in the monoidal definition, &lt;code&gt;map&lt;/code&gt; is left abstract.&lt;/p&gt;

&lt;p&gt;The laws for monoidal functors are the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Iso[A, B] { def apply(a: A): B }

implicit class IsoOps[A](val a: A) {
  def ~=[B](b: B)(implicit iso: Iso[A, B]): Boolean = iso(a) == b
}

def monoidalLeftIdentity[F[_], A](fa: F[A])(implicit F: Monoidal[F], iso: Iso[F[(Unit, A)], F[A]]): Boolean =
  F.zip(F.unit, fa) ~= fa

def monoidalRightIdentity[F[_], A](fa: F[A])(implicit F: Monoidal[F], iso: Iso[F[(A, Unit)], F[A]]): Boolean =
  F.zip(fa, F.unit) ~= fa

def monoidalAssociativity[F[_], A, B, C](fa: F[A], fb: F[B], fc: F[C])(implicit F: Monoidal[F], iso: Iso[F[(A, (B, C))], F[((A, B), C)]]): Boolean =
  F.zip(fa, F.zip(fb, fc)) ~= F.zip(F.zip(fa, fb), fc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The identity laws state that zipping a value with the unit value yields the original value, ignoring the tuple structure. The associativity law requires &lt;code&gt;zip&lt;/code&gt; to be associative, again ignoring the tuple structure. Here, like in the Typeclassopedia definition, we defer the equality checking to an isomorphism that ignores the unwanted structure.&lt;/p&gt;

&lt;p&gt;We could further generalize this type class by removing the requirement for the &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; operations, leaving simply &lt;code&gt;zip&lt;/code&gt; along with the associativity law &amp;ndash; this is exactly what Scalaz has done with the &lt;code&gt;scalaz.Zip&lt;/code&gt; type class.&lt;/p&gt;

&lt;h3 id=&#34;converting-applicative-forms&#34;&gt;Converting applicative forms&lt;/h3&gt;

&lt;p&gt;We can convert any applicative functor to a monoidal functor and vice-versa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def applicativeToMonoidal[F[_]](implicit F: Applicative[F]): Monoidal[F] = new Monoidal[F] {
  def unit: F[Unit] = F.pure(())
  def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)] = F.ap(fb)(F.map(fa)(a =&amp;gt; (b: B) =&amp;gt; (a, b)))
  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B] = F.map(fa)(f)
}

implicit def monoidalToApplicative[F[_]](implicit F: Monoidal[F]): Applicative[F] = new Applicative[F] {
  def pure[A](a: A): F[A] = F.map(F.unit)(_ =&amp;gt; a)
  def ap[A, B](fa: F[A])(ff: F[A =&amp;gt; B]): F[B] = F.map(F.zip(fa, ff)) { case (a, f) =&amp;gt; f(a) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;monoidal-codec&#34;&gt;Monoidal[Codec]&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s try to implement a &lt;code&gt;Monoidal&lt;/code&gt; instance for &lt;code&gt;Codec&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The definition of &lt;code&gt;unit&lt;/code&gt; looks very similar to the definition of &lt;code&gt;pure&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def unit: Codec[Unit] = new Codec[Unit] {
  def sizeBound = SizeBound.exact(0)
  def encode(a: A) = Attempt.successful(BitVector.empty)
  def decode(b: BitVector) = Attempt.successful(DecodeResult((), b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s try to implement &lt;code&gt;zip&lt;/code&gt; &amp;ndash; note that we should not be able to, as we know &lt;code&gt;Codec&lt;/code&gt; doesn&amp;rsquo;t have a covariant functor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def zip[A, B](ca: Codec[A], cb: Codec[B]): Codec[(A, B)] = new Codec[(A, B)] {
  def sizeBound = ca.sizeBound + cb.sizeBound
  def decode(b: BitVector) = (for {
    a &amp;lt;- DecodingContext(ca)
    b &amp;lt;- DecodingContext(cb)
  } yield (a, b)).decode(b)
  def encode(ab: (A, B)) = for {
    encA &amp;lt;- ca.encode(ab._1)
    encB &amp;lt;- cb.encode(ab._2)
  } yield encA ++ encB
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait, so what are we missing? We have an implementation of &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;zip&lt;/code&gt; and yet we know we can&amp;rsquo;t have a lawful &lt;code&gt;Monoidal[Codec]&lt;/code&gt; instance due to the fact that there&amp;rsquo;s no covariant functor for &lt;code&gt;Codec&lt;/code&gt;. Monoidal functors have &lt;em&gt;three&lt;/em&gt; abstract operations though, not two (like &lt;code&gt;Applicative&lt;/code&gt;) &amp;ndash; &lt;code&gt;unit&lt;/code&gt;, &lt;code&gt;zip&lt;/code&gt;, and &lt;code&gt;map&lt;/code&gt;. So in order to have a monoidal functor for &lt;code&gt;Codec&lt;/code&gt;, we need to define &lt;code&gt;map&lt;/code&gt;, which we know we can&amp;rsquo;t do!&lt;/p&gt;

&lt;p&gt;However, we do have &lt;code&gt;xmap&lt;/code&gt;. What happens if we pair &lt;code&gt;xmap&lt;/code&gt; with &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;zip&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id=&#34;invariant-monoidal-functors&#34;&gt;Invariant monoidal functors&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s define a new invariant shadow of &lt;code&gt;Monoidal&lt;/code&gt; that extends &lt;code&gt;InvariantFunctor&lt;/code&gt; instead of &lt;code&gt;Functor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait InvariantMonoidal[F[_]] extends InvariantFunctor[F] {
  def unit: F[Unit]
  def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also port the laws from lax monoidal functors, which are identical except for requiring an &lt;code&gt;InvariantMonoidal&lt;/code&gt; instance instead of a &lt;code&gt;Monoidal&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def xmonoidalLeftIdentity[F[_], A](fa: F[A])(implicit F: InvariantMonoidal[F], iso: Iso[F[(Unit, A)], F[A]]): Boolean =
  F.zip(F.unit, fa) ~= fa

def xmonoidalRightIdentity[F[_], A](fa: F[A])(implicit F: InvariantMonoidal[F], iso: Iso[F[(A, Unit)], F[A]]): Boolean =
  F.zip(fa, F.unit) ~= fa

def xmonoidalAssociativity[F[_], A, B, C](fa: F[A], fb: F[B], fc: F[C])(implicit F: InvariantMonoidal[F], iso: Iso[F[(A, (B, C))], F[((A, B), C)]]): Boolean =
  F.zip(fa, F.zip(fb, fc)) ~= F.zip(F.zip(fa, fb), fc)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;deriving-an-invariantmonoidal-from-an-invariantmonad&#34;&gt;Deriving an &lt;code&gt;InvariantMonoidal&lt;/code&gt; from an &lt;code&gt;InvariantMonad&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In the same way that a monad yields two monoidal functors (or two applicative functors) &amp;ndash; one that evaluates &lt;code&gt;F[A]&lt;/code&gt; first and &lt;code&gt;F[B]&lt;/code&gt; second, and another which evaluates in the reverse order &amp;ndash; an invariant monad gives rise to two invariant monoidal functors. For example, the following implementation evaluates the &lt;code&gt;F[A]&lt;/code&gt; first and the &lt;code&gt;F[B]&lt;/code&gt; second:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def xmonadToXmonoidal[F[_]](implicit F: InvariantMonad[F]): InvariantMonoidal[F] = new InvariantMonoidal[F] {
  def unit: F[Unit] = F.pure(())
  def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
    F.xflatMap(fa)(a =&amp;gt; F.xmap(fb)(b =&amp;gt; (a, b))(ab =&amp;gt; ab._2))(ab =&amp;gt; ab._1)
  def xmap[A, B](fa: F[A])(f: A =&amp;gt; B)(g: B =&amp;gt; A): F[B] = F.xmap(fa)(f)(g)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sharing-unit-zip&#34;&gt;Sharing unit/zip&lt;/h3&gt;

&lt;p&gt;Because the invariant monoidal differs from the covariant monoidal only in the defintion of &lt;code&gt;xmap&lt;/code&gt;/&lt;code&gt;map&lt;/code&gt;, we could extract a type class that captures the signature of &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;zip&lt;/code&gt; and the laws that govern their interaction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait MonoidalBase[F[_]] {
  def unit: F[Unit]
  def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
trait Monoidal[F[_]] extends MonoidalBase[F] with Functor[F]
trait InvariantMonoidal[F[_]] extends MonoidalBase[F] with InvariantFunctor[F]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;applicability-to-codec&#34;&gt;Applicability to Codec&lt;/h2&gt;

&lt;p&gt;In the last article, we saw that &lt;code&gt;Codec&lt;/code&gt; supported both &lt;code&gt;flatZip&lt;/code&gt; and &lt;code&gt;consume&lt;/code&gt;, and how those methods exist due to the invariant monad structure of &lt;code&gt;Codec&lt;/code&gt;. In fact, those methods both existed &lt;em&gt;before&lt;/em&gt; the invariant monad structure was extracted. Is the same true for &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;zip&lt;/code&gt;? That is, do those methods exist under some other name, their existence justified by their usefulness in binary codec creation, rather than satisfying a type class definition?&lt;/p&gt;

&lt;p&gt;It turns out that both of these operations do exist already. The &lt;code&gt;unit&lt;/code&gt; operation is provided by &lt;code&gt;scodec.codecs.ignore(0L)&lt;/code&gt;, which returns a &lt;code&gt;Codec[Unit]&lt;/code&gt; that encodes an empty bit vector. The &lt;code&gt;zip&lt;/code&gt; operation is provided by the &lt;code&gt;pairedWith&lt;/code&gt; method on codec &amp;ndash; which has the operator alias &lt;code&gt;~&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We did not provide an invariant shadow of applicative functors, though that is worth exploring, perhaps in a future article.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Invariant Shadows</title>
      <link>https://mpilquist.github.io/blog/2015/06/18/invariant-shadows/</link>
      <pubDate>Thu, 18 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2015/06/18/invariant-shadows/</guid>
      <description>

&lt;p&gt;A common use case when working with binary protocols is decoding a value and then using the decoded value to determine how to decode the remaining bits. For example, consider a simple framing structure, made up of a 2-byte big endian unsigned integer field followed by &lt;code&gt;n&lt;/code&gt; bytes, where &lt;code&gt;n&lt;/code&gt; is the value in the first field. In order to decode this structure, we need to first decode the 2-byte size field, then use the decoded size to take that number of bytes from the remainder.&lt;/p&gt;

&lt;p&gt;This can be represented with &lt;a href=&#34;http://scodec.org&#34;&gt;scodec&lt;/a&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scodec._
import scodec.bits._
import scodec.codecs._

val decoder: Decoder[ByteVector] = uint16 flatMap { size =&amp;gt; bytes(size * 8L) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we used &lt;code&gt;flatMap&lt;/code&gt; to express the dependency between &lt;code&gt;uint16: Codec[Int]&lt;/code&gt; and the bytes decoder. However, &lt;code&gt;flatMap&lt;/code&gt; on &lt;code&gt;Codec&lt;/code&gt; returns
a &lt;code&gt;Decoder[B]&lt;/code&gt;, not a &lt;code&gt;Codec[B]&lt;/code&gt;, so by using &lt;code&gt;flatMap&lt;/code&gt;, we lose the ability to encode.&lt;/p&gt;

&lt;p&gt;It turns out that it is impossible to define &lt;code&gt;flatMap&lt;/code&gt; for &lt;code&gt;Codec&lt;/code&gt; with the expected signature. Consider this attempt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Codec[A] extends Encoder[A] with Decoder[A] { self =&amp;gt;

  def flatMap[B](f: A =&amp;gt; Codec[B]): Codec[B] = new Codec[B] {
    def sizeBound = self.sizeBound.atLeast
    def decode(b: BitVector): Attempt[DecodeResult[B]] =
      self.decode(b).flatMap { res =&amp;gt; f(res.value).decode(res.remainder) }
    def encode(b: B): Attempt[BitVector] =
      ???
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implementation of &lt;code&gt;decode&lt;/code&gt; is straightforward, but we arrive at an impasse when trying to implement &lt;code&gt;encode&lt;/code&gt;. We have a &lt;code&gt;Codec[A]&lt;/code&gt;, a function &lt;code&gt;A =&amp;gt; Codec[B]&lt;/code&gt; and a value of type &lt;code&gt;B&lt;/code&gt;. We cannot use the &lt;code&gt;Codec[A]&lt;/code&gt; to encode unless we have an &lt;code&gt;A&lt;/code&gt;, and we cannot get access to a &lt;code&gt;Codec[B]&lt;/code&gt; unless we have an &lt;code&gt;A&lt;/code&gt; to apply to the function. Hence, we cannot implement &lt;code&gt;flatMap&lt;/code&gt; on &lt;code&gt;Codec&lt;/code&gt; &amp;ndash; meaning that there is no monad for &lt;code&gt;Codec&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;So how were we able to call &lt;code&gt;flatMap&lt;/code&gt; on &lt;code&gt;Codec&lt;/code&gt; in our first example? That worked because &lt;code&gt;Decoder&lt;/code&gt; defines a &lt;code&gt;flatMap&lt;/code&gt; method like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Decoder[+A] { self =&amp;gt;

  def flatMap[B](f: A =&amp;gt; Decoder[B]): Decoder[B] = new Decoder[B] {
    def decode(b: BitVector): Attempt[DecodeResult[B]] =
      self.decode(b).flatMap { res =&amp;gt; f(res.value).decode(res.remainder) }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;Codec&lt;/code&gt; extends from &lt;code&gt;Decoder&lt;/code&gt;, it inherits this definition of &lt;code&gt;flatMap&lt;/code&gt;, which is why flat mapping a &lt;code&gt;Codec&lt;/code&gt; results in a &lt;code&gt;Decoder&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nonetheless, we can change the signature of &lt;code&gt;flatMap&lt;/code&gt; slightly in order to get much of the utility of &lt;code&gt;flatMap&lt;/code&gt; without running in to our impasse when encoding. In our ill-fated attempt at implementing &lt;code&gt;flatMap&lt;/code&gt;, we were short a value of &lt;code&gt;A&lt;/code&gt;. Hence, we can ask the caller to provide the &lt;code&gt;A&lt;/code&gt; value. A particularly useful way of doing so is changing the return type from &lt;code&gt;Codec[B]&lt;/code&gt; to &lt;code&gt;Codec[(A, B)]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This has implications on both decoding and encoding &amp;ndash; when decoding, we need to return the decoded &lt;code&gt;A&lt;/code&gt; in the overall result instead of using it solely to generate the &lt;code&gt;Codec[B]&lt;/code&gt;, whereas in encoding, we need to encode the input &lt;code&gt;A&lt;/code&gt;, apply the function with the same &lt;code&gt;A&lt;/code&gt; to create a &lt;code&gt;Codec[B]&lt;/code&gt;, encode the input &lt;code&gt;B&lt;/code&gt;, and finally concatenate the encoded forms of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. The signature is the same as &lt;code&gt;flatMap&lt;/code&gt; except the result type is &lt;code&gt;Codec[(A, B)]&lt;/code&gt; instead of &lt;code&gt;Codec[B]&lt;/code&gt; &amp;ndash; so for now, let&amp;rsquo;s call this &lt;code&gt;flatZip&lt;/code&gt; since it zips &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in to a tuple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Codec[A] extends Encoder[A] with Decoder[A] { self =&amp;gt;

  def flatZip[B](f: A =&amp;gt; Codec[B]): Codec[(A, B)] = new Codec[(A, B)] {
    def sizeBound = self.sizeBound.atLeast
    def decode(b: BitVector): Attempt[DecodeResult[(A, B)]] =
      self.decode(b).flatMap { res =&amp;gt;
        val a = res.value
        val bres = f(a).decode(res.remainder)
        bres.map { _.map { b =&amp;gt; (a, b) } }
      }
    def encode(ab: (A, B)): Attempt[BitVector] = for {
      encA &amp;lt;- self.encode(ab._1)
      codecB = f(ab._1)
      encB &amp;lt;- codecB.encode(ab._2)
    } yield encA ++ encB
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another solution to the &lt;code&gt;flatMap&lt;/code&gt; dilemma is keeping the return type as &lt;code&gt;Codec[B]&lt;/code&gt; but adding another parameter to the method that lets us materialize an &lt;code&gt;A&lt;/code&gt; from what we have &amp;ndash; namely, a &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Codec[A] extends Encoder[A] with Decoder[A] { self =&amp;gt;

  def consume[B](f: A =&amp;gt; Codec[B])(g: B =&amp;gt; A): Codec[B] = new Codec[B] {
    def sizeBound = self.sizeBound.atLeast
    def decode(b: BitVector): Attempt[DecodeResult[B]] =
      self.decode(b).flatMap { res =&amp;gt; f(res.value).decode(res.remainder) }
    def encode(b: B): Attempt[BitVector] = {
      val a = g(b)
      for {
        encA &amp;lt;- self.encode(a)
        codecB = f(a)
        encB &amp;lt;- codecB.encode(b)
      } yield encA ++ encB
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One interesting use case for &lt;code&gt;consume&lt;/code&gt; is handling header fields whose values are derived from the body. For instance, see &lt;a href=&#34;https://github.com/scodec/scodec/blob/2d790190617b8025ce22c7c9f041f1a7a52a8d84/shared/src/test/scala/scodec/examples/ProductsExample.scala#L86-L103&#34;&gt;this example from scodec&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An interesting property of these methods is that they can be implemented in terms of one another, as long as we have the &lt;code&gt;xmap&lt;/code&gt; operation.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;consume(f)(g) == flatZip(f).xmap[B](ab =&amp;gt; ab._2)(b =&amp;gt; (g(b), b))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flatZip(f) == consume(a =&amp;gt; f(a).xmap[(A, B)](b =&amp;gt; (a, b))(ab =&amp;gt; ab._2))(ab =&amp;gt; ab._1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The scodec library provides both of these methods, as they are useful in different scenarios. However, these identities show that they are just different formulations of the same concept.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-naming&#34;&gt;A note on naming&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;flatZip&lt;/code&gt; name leaves a lot to be desired. We selected it based on an appeal to how the method is &lt;code&gt;flatMap&lt;/code&gt;-like in signature but returns a tuple &amp;ndash; zipping the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. &lt;code&gt;flatMapAndZip&lt;/code&gt; is way too long and a bit deceiving, as it implies that the operation is the result of composing zipping with &lt;code&gt;flatMap&lt;/code&gt;. Additionally, we are only really zipping on the decoder side &amp;ndash; when encoding, the user is passing the tuple to us. Zip describes the action that builds the tuple, but it would be clearer to describe the tuple itself. Using &lt;code&gt;product&lt;/code&gt; to refer to the product type &lt;code&gt;(A, B)&lt;/code&gt;, we could call this operation &lt;code&gt;flatMapProduct&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;consume&lt;/code&gt; name could also be improved upon. For starters, it is evocative. Worse, the rationale for its name applies equally well when using &lt;code&gt;consume&lt;/code&gt; as an alias for &lt;code&gt;flatMap&lt;/code&gt;. Re-examining the signature shows us that &lt;code&gt;consume&lt;/code&gt; is like &lt;code&gt;flatMap&lt;/code&gt; but takes an extra parameter, &lt;code&gt;B =&amp;gt; A&lt;/code&gt;. There doesn&amp;rsquo;t seem to be much help in naming there. Instead, let&amp;rsquo;s use our identity to help name the operation. We&amp;rsquo;ve shown that &lt;code&gt;consume&lt;/code&gt; can be written in terms of &lt;code&gt;flatMapProduct&lt;/code&gt; and &lt;code&gt;xmap&lt;/code&gt;. Hence, &lt;code&gt;consume&lt;/code&gt; is like an invariant version of the (covariant) &lt;code&gt;flatMap&lt;/code&gt;. Informed by the fact that we use &lt;code&gt;xmap&lt;/code&gt; as the invariant form of the (covariant) &lt;code&gt;map&lt;/code&gt; method, we&amp;rsquo;ll call this operation &lt;code&gt;xflatMap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Knowing that &lt;code&gt;flatMapProduct&lt;/code&gt; depends on &lt;code&gt;xmap&lt;/code&gt;, let&amp;rsquo;s use the same convention there as well and call it &lt;code&gt;xflatMapProduct&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Naming is hard.&lt;/p&gt;

&lt;h2 id=&#34;generalizing&#34;&gt;Generalizing&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s extract a type class for this operation. Here, we&amp;rsquo;ll pick &lt;code&gt;xflatMap&lt;/code&gt; as the primary operation and define &lt;code&gt;xflatMapProduct&lt;/code&gt; in terms of &lt;code&gt;xflatMap&lt;/code&gt;, but the inverse would be equally useful. Let&amp;rsquo;s also assume we have an invariant functor type class available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait InvariantFunctor[F[_]] {
  def xmap[A, B](fa: F[A])(f: A =&amp;gt; B)(g: B =&amp;gt; A): F[B]
}

trait InvariantFlatMap[F[_]] extends InvariantFunctor[F] {

  def xflatMap[A, B](fa: F[A])(f: A =&amp;gt; F[B])(g: B =&amp;gt; A): F[B]

  def xflatMapProduct[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[(A, B)] =
    xflatMap[A, (A, B)](fa)(a =&amp;gt; xmap[B, (A, B)](f(a))(b =&amp;gt; (a, b))(ab =&amp;gt; ab._2))(ab =&amp;gt; ab._1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What laws can we write that govern the behavior of &lt;code&gt;xflatMap&lt;/code&gt;? We could use the same laws as the normal &lt;code&gt;FlatMap&lt;/code&gt; type class adjusted for the extra &lt;code&gt;g&lt;/code&gt; parameter &amp;ndash; namely, that &lt;code&gt;xflatMap&lt;/code&gt; is associative.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def xflatMapAssociativity[F[_], A, B, C](
  fa: F[A], f: A =&amp;gt; F[B], fi: B =&amp;gt; A, g: B =&amp;gt; F[C], gi: C =&amp;gt; B
)(implicit F: InvariantFlatMap[F]): Boolean =
  F.xflatMap(F.xflatMap(fa)(f)(fi))(g)(gi) ==
    F.xflatMap(fa)(a =&amp;gt; F.xflatMap(f(a))(g)(gi))(gi andThen fi)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallels-with-flatmap&#34;&gt;Parallels with &lt;code&gt;FlatMap&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The (covariant) &lt;code&gt;FlatMap&lt;/code&gt; type class corresponds to &lt;code&gt;InvariantFlatMap&lt;/code&gt; in the same way that (covariant) &lt;code&gt;Functor&lt;/code&gt; corresponds to &lt;code&gt;InvariantFunctor&lt;/code&gt;. For example, any &lt;code&gt;FlatMap&lt;/code&gt; instance gives rise to an &lt;code&gt;InvariantFlatMap&lt;/code&gt; instance which simply ignores the &lt;code&gt;g&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;What about &lt;code&gt;xflatMapProduct&lt;/code&gt; though? There&amp;rsquo;s nothing to remove or ignore in its signature, so how can there be a correspondence to a covariant equivalent? The covariant equivalent of &lt;code&gt;xflatMapProduct&lt;/code&gt; differs not in signature, but in implementation &amp;ndash; specifically, it uses the covariant &lt;code&gt;map&lt;/code&gt; instead of the invariant &lt;code&gt;xmap&lt;/code&gt;. In fact, the covariant equivalent of &lt;code&gt;xflatMapProduct&lt;/code&gt; is known as &lt;code&gt;mproduct&lt;/code&gt; in Haskell &amp;ndash; short for &amp;ldquo;monad product&amp;rdquo;, which is interesting because it does not rely on a full monad struture, but rather, only the structure of &lt;code&gt;FlatMap&lt;/code&gt;/&lt;code&gt;Bind&lt;/code&gt;. Naming is hard. (To be fair, &lt;code&gt;mproduct&lt;/code&gt; exists in the Haskell standard library, which does not include the &lt;code&gt;Bind&lt;/code&gt; type class.)&lt;/p&gt;

&lt;h2 id=&#34;further-generalization-with-fast-and-loose-reasoning&#34;&gt;Further Generalization with Fast and Loose Reasoning&lt;/h2&gt;

&lt;p&gt;Building off these correspondences, can we create an &lt;code&gt;InvariantMonad&lt;/code&gt; type class by adding a &lt;code&gt;pure&lt;/code&gt; method to an &lt;code&gt;InvariantFunctor&lt;/code&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait InvariantMonad[F[_]] extends InvariantFlatMap[F] {
  def pure[A](a: A): F[A]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the associativity law inherited from &lt;code&gt;InvariantFlatMap&lt;/code&gt; along with a left and right identity law:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def invariantMonadLeftIdentity[F[_], A, B](a: A, f: A =&amp;gt; F[B], fi: B =&amp;gt; A)(implicit F: InvariantMonad[F]): Boolean =
  F.xflatMap(F.pure(a))(f)(fi) == f(a)

def invariantMonadRightIdentity[F[_], A](fa: F[A])(implicit F: InvariantMonad[F]): Boolean =
  F.xflatMap(fa)(a =&amp;gt; F.pure(a))(identity) == fa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now port arbitrary functions that work with monads to work with invariant monads &amp;ndash; compensating for the extra inverse function as appropriate.&lt;/p&gt;

&lt;h2 id=&#34;parting-thoughts&#34;&gt;Parting Thoughts&lt;/h2&gt;

&lt;p&gt;Starting with a concrete example from scodec, we allowed the type system to guide us in the development of &lt;code&gt;flatZip&lt;/code&gt; and &lt;code&gt;consume&lt;/code&gt;. By generalizing the resulting operations, we were able to focus on the structure, with no implied meaning from binary serialization. Once we realized that we had build an invariant form of &lt;code&gt;FlatMap&lt;/code&gt;, we were able to use loose reasoning based on correspondences with familiar type classes to develop an invariant form of &lt;code&gt;Monad&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Continuously shifting between working with concrete types and working with minimally expressive type classes, allowing the findings from each style to inform the work in the opposite style, is a powerful technique in API development.&lt;/p&gt;

&lt;p&gt;Further work will focus on development of an &lt;code&gt;InvariantApplicative&lt;/code&gt; type class, along with finding more applications of these invariant type classes in scodec.&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;Special thanks to Paul Chiusano for some thoughtful discussion of these topics.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functional Structures in Scala Screencast Series</title>
      <link>https://mpilquist.github.io/blog/2015/04/22/functional-structures/</link>
      <pubDate>Wed, 22 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mpilquist.github.io/blog/2015/04/22/functional-structures/</guid>
      <description>&lt;p&gt;Informal talk series that presents the major functional programming type classes in Scala.&lt;/p&gt;

&lt;p&gt;Talks are intended to complement the fantastic Functional Programming in Scala by Paul Chiusano and RÃºnar Bjarnason (&lt;a href=&#34;http://www.manning.com/bjarnason/&#34;&gt;http://www.manning.com/bjarnason/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Given the informal nature of the talks, there are mistakes. Errata will be posted on each talk in the descriptions.&lt;/p&gt;

&lt;p&gt;
&lt;div class=&#34;video-container&#34;&gt;
  &lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Dsd4pc99FSY?list=PLFrwDVdSrYE6dy14XCmUtRAJuhCxuzJp0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>